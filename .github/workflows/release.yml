name: release
permissions:
  actions: read # Read workflow data
  contents: write # Read repository contents

on:
  push:
    tags:
      - "*"
    branches:
      - "packagetest"

jobs:
  goreleaser:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: "1.25"

      - name: set up helm
        uses: azure/setup-helm@v4
        with:
          version: "latest"

      - name: Import GPG key
        id: import_gpg
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.PASSPHRASE }}

      - name: Run GoReleaser (build only)
        uses: goreleaser/goreleaser-action@v6
        with:
          version: latest
          args: build --snapshot --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GPG_FINGERPRINT: ${{ steps.import_gpg.outputs.fingerprint }}

      - name: Configure GPG for Helm compatibility
        env:
          GPG_KEY: ${{ steps.import_gpg.outputs.keyid }}
          GPG_PASSPHRASE: ${{ secrets.PASSPHRASE }}
        run: |
          # Set GNUPGHOME explicitly
          export GNUPGHOME="${HOME}/.gnupg"

          # # Configure GPG for non-interactive use
          # cat > "${GNUPGHOME}/gpg.conf" <<EOF
          # use-agent
          # pinentry-mode loopback
          # batch
          # yes
          # EOF

          # cat > "${GNUPGHOME}/gpg-agent.conf" <<EOF
          # allow-loopback-pinentry
          # default-cache-ttl 34560000
          # max-cache-ttl 34560000
          # EOF

          # # Restart GPG agent
          # gpgconf --kill gpg-agent
          # gpg-connect-agent /bye

          # # Export public keys to old format that Helm expects
          # echo "Exporting public keys to legacy format..."
          # gpg --export > "${GNUPGHOME}/pubring.gpg"

          # Export secret keys with passphrase
          echo "Exporting secret keys to legacy format..."
          # echo "${GPG_PASSPHRASE}" | gpg --batch --yes \
          echo "${GPG_PASSPHRASE}" | gpg \
            --pinentry-mode loopback \
            --passphrase-fd 0 \
            --export-secret-keys > "${GNUPGHOME}/secring.gpg"

          # Set proper permissions
          # chmod 600 "${GNUPGHOME}/secring.gpg"
          # chmod 644 "${GNUPGHOME}/pubring.gpg"

          # Verify the files were created
          echo "Keyring files:"
          ls -lah "${GNUPGHOME}/"*.gpg

          # Test GPG signing
          echo "Testing GPG signing..."
          echo "test" | gpg --batch --yes \
            --passphrase "${GPG_PASSPHRASE}" \
            --pinentry-mode loopback \
            --armor --detach-sign \
            --local-user "${GPG_KEY}" \
            --output /tmp/test.sig
          rm /tmp/test.sig
          echo "✓ GPG setup complete and tested"

      - name: package
        env:
          GPG_KEY_ID: ${{ steps.import_gpg.outputs.keyid }}
          GPG_KEY_EMAIL: ${{ steps.import_gpg.outputs.email }}
          GPG_PASSPHRASE: ${{ secrets.PASSPHRASE }}
          GNUPGHOME: /home/runner/.gnupg
        run: |
          # Extract version from tag or use snapshot for branches
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            # For non-tag builds, use version from plugin.yaml with snapshot suffix
            VERSION=$(grep "version:" plugin.yaml | cut -d '"' -f 2)-snapshot
          fi
          echo ${VERSION}

          # Debug: Check GPG keys
          echo "=== GPG Key Information ==="
          echo "Key ID: ${GPG_KEY_ID}"
          echo "Key Email: ${GPG_KEY_EMAIL}"
          echo ""
          echo "Secret keys available:"
          gpg --list-secret-keys
          echo ""
          echo "Public keys available:"
          gpg --list-keys
          echo ""
          echo "Legacy keyring files:"
          ls -lah "${GNUPGHOME}/"*.gpg || echo "No .gpg files found"
          echo ""

          echo "Using GPG key: ${GPG_KEY_EMAIL}"

          # Create output directory
          mkdir -p packaged-plugins

          # Package for each platform/arch combination
          echo "$GPG_PASSPHRASE" > passphrase.txt
          for os in darwin linux windows; do
            for arch in amd64 arm64; do
              DIST_PATH="dist/helm-push_${os}_${arch}_v1"

              # Check if the goreleaser dist directory exists
              if [ ! -d "${DIST_PATH}" ]; then
                echo "Skipping ${os}/${arch} - not built"
                continue
              fi

              echo "Packaging ${os}/${arch}..."

              # Create a temporary plugin directory with correct structure
              PLUGIN_DIR=$(mktemp -d)
              mkdir -p "${PLUGIN_DIR}/bin"
              mkdir -p "${PLUGIN_DIR}/testdata"

              # Copy files from goreleaser output
              cp "${DIST_PATH}/bin/helm-cm-push"* "${PLUGIN_DIR}/bin/"
              cp plugin.yaml "${PLUGIN_DIR}/"
              cp testdata/plugin-helm3.yaml "${PLUGIN_DIR}/testdata/"
              cp LICENSE "${PLUGIN_DIR}/"

              # Update plugin.yaml version if needed
              sed -i "s|version: .*|version: \"${VERSION}\"|" "${PLUGIN_DIR}/plugin.yaml"
              sed -i "s|version: .*|version: \"${VERSION}\"|" "${PLUGIN_DIR}/testdata/plugin-helm3.yaml"

              # Package and sign with helm
              OUTPUT_NAME="helm-push_${VERSION}_${os}_${arch}.tgz"
              OUTPUT_PATH="${GITHUB_WORKSPACE}/packaged-plugins/${OUTPUT_NAME}"

              # Try helm plugin package with signing
              if helm plugin package "${PLUGIN_DIR}" \
                --destination packaged-plugins \
                --sign \
                --key "${GPG_KEY_EMAIL}" \
                --keyring "${GNUPGHOME}/secring.gpg" \
                --passphrase-file passphrase.txt 2>&1; then

                echo "✓ Helm plugin package with signing succeeded"

                # Find the generated files (helm may generate different names)
                LATEST_TGZ=$(ls -t packaged-plugins/*.tgz 2>/dev/null | head -1)
                LATEST_PROV=$(ls -t packaged-plugins/*.tgz.prov 2>/dev/null | head -1)

                # Rename to our naming convention if files were created
                if [ -n "${LATEST_TGZ}" ] && [ -f "${LATEST_TGZ}" ]; then
                  mv "${LATEST_TGZ}" "packaged-plugins/${OUTPUT_NAME}"
                  if [ -n "${LATEST_PROV}" ] && [ -f "${LATEST_PROV}" ]; then
                    mv "${LATEST_PROV}" "packaged-plugins/${OUTPUT_NAME}.prov"
                  fi
                fi
              else
                echo "Helm plugin package --sign failed, using manual GPG signing"

                # Manual packaging
                tar -czf "${OUTPUT_PATH}" -C "${PLUGIN_DIR}" .
                cd "${GITHUB_WORKSPACE}"

                # Manual GPG signing
                echo "${GPG_PASSPHRASE}" | gpg --batch --yes \
                  --passphrase-fd 0 \
                  --pinentry-mode loopback \
                  --armor \
                  --detach-sign \
                  --local-user "${GPG_KEY_ID}" \
                  --output "packaged-plugins/${OUTPUT_NAME}.prov" \
                  "packaged-plugins/${OUTPUT_NAME}"

                echo "✓ Manual signing succeeded"
              fi

              # Cleanup temp directory
              rm -rf "${PLUGIN_DIR}"

              echo "✓ Created ${OUTPUT_NAME}"
            done
          done
          rm passphrase.txt

          # List created packages
          echo ""
          echo "Created packages:"
          ls -lh packaged-plugins/

      # - name: Upload packages to release
      #   uses: softprops/action-gh-release@v2
      #   with:
      #     files: |
      #       packaged-plugins/*.tgz
      #       packaged-plugins/*.prov
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
