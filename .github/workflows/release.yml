name: release
permissions:
  actions: read # Read workflow data
  contents: write # Read repository contents

on:
  push:
    tags:
      - "*"
    branches:
      - "packagetest"

jobs:
  goreleaser:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: "1.25"

      - name: set up helm
        uses: azure/setup-helm@v4
        with:
          version: "latest"

      - name: Import GPG key
        id: import_gpg
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.PASSPHRASE }}

      - name: Run GoReleaser (build only)
        uses: goreleaser/goreleaser-action@v6
        with:
          version: latest
          args: release --snapshot --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GPG_FINGERPRINT: ${{ steps.import_gpg.outputs.fingerprint }}

      - name: package
        env:
          GPG_KEY: ${{ steps.import_gpg.outputs.email }}
          GPG_PASSPHRASE: ${{ secrets.PASSPHRASE }}
        run: |
          VERSION=${GITHUB_REF#refs/tags/}

          # Set GNUPGHOME explicitly
          export GNUPGHOME="${HOME}/.gnupg"

          # Configure GPG agent for non-interactive use
          echo "use-agent" > "${GNUPGHOME}/gpg.conf"
          echo "pinentry-mode loopback" >> "${GNUPGHOME}/gpg.conf"
          echo "allow-loopback-pinentry" > "${GNUPGHOME}/gpg-agent.conf"
          gpg-connect-agent reloadagent /bye || true

          # Verify GPG setup
          echo "Available GPG keys:"
          gpg --list-secret-keys

          echo "Using GPG key: ${GPG_KEY}"

          # Test GPG signing to cache passphrase
          echo "test" | gpg --batch --yes --passphrase "${GPG_PASSPHRASE}" \
            --pinentry-mode loopback \
            --armor --detach-sign --local-user "${GPG_KEY}" \
            --output /tmp/test.sig
          rm /tmp/test.sig
          echo "✓ GPG signing test successful"

          # Create a temporary directory for packaging
          mkdir -p packaged-plugins

          # Package for each platform/arch combination
          for os in darwin linux windows; do
            for arch in amd64 arm64; do
              DIST_PATH="dist/helm-push_${os}_${arch}_v1"

              # Check if the goreleaser dist directory exists
              if [ ! -d "${DIST_PATH}" ]; then
                echo "Skipping ${os}/${arch} - not built"
                continue
              fi

              echo "Packaging ${os}/${arch}..."

              # Create a temporary plugin directory with correct structure
              PLUGIN_DIR=$(mktemp -d)
              mkdir -p "${PLUGIN_DIR}/bin"
              mkdir -p "${PLUGIN_DIR}/testdata"

              # Copy files from goreleaser output
              cp "${DIST_PATH}/bin/helm-cm-push"* "${PLUGIN_DIR}/bin/"
              cp plugin.yaml "${PLUGIN_DIR}/"
              cp testdata/plugin-helm3.yaml "${PLUGIN_DIR}/testdata/"
              cp LICENSE "${PLUGIN_DIR}/"

              # Update plugin.yaml version if needed
              sed -i "s/version: .*/version: \"${VERSION}\"/" "${PLUGIN_DIR}/plugin.yaml"
              sed -i "s/version: .*/version: \"${VERSION}\"/" "${PLUGIN_DIR}/testdata/plugin-helm3.yaml"

              # Package and sign with helm
              OUTPUT_NAME="helm-push_${VERSION}_${os}_${arch}.tgz"

              # Try helm plugin package with signing
              if helm plugin package "${PLUGIN_DIR}" \
                --destination packaged-plugins \
                --sign \
                --key "${GPG_KEY}" 2>&1; then

                echo "✓ Helm plugin package with signing succeeded"

                # Find the generated files (helm may generate different names)
                LATEST_TGZ=$(ls -t packaged-plugins/*.tgz 2>/dev/null | head -1)
                LATEST_PROV=$(ls -t packaged-plugins/*.tgz.prov 2>/dev/null | head -1)

                # Rename to our naming convention if files were created
                if [ -n "${LATEST_TGZ}" ] && [ -f "${LATEST_TGZ}" ]; then
                  mv "${LATEST_TGZ}" "packaged-plugins/${OUTPUT_NAME}"
                  if [ -n "${LATEST_PROV}" ] && [ -f "${LATEST_PROV}" ]; then
                    mv "${LATEST_PROV}" "packaged-plugins/${OUTPUT_NAME}.prov"
                  fi
                fi
              else
                echo "Helm plugin package --sign failed, using manual GPG signing"

                # Manual packaging
                cd "${PLUGIN_DIR}"
                tar czf "${OUTPUT_NAME}" .
                mv "${OUTPUT_NAME}" "${GITHUB_WORKSPACE}/packaged-plugins/"
                cd "${GITHUB_WORKSPACE}"

                # Manual GPG signing
                echo "${GPG_PASSPHRASE}" | gpg --batch --yes \
                  --passphrase-fd 0 \
                  --pinentry-mode loopback \
                  --armor \
                  --detach-sign \
                  --local-user "${GPG_KEY}" \
                  --output "packaged-plugins/${OUTPUT_NAME}.prov" \
                  "packaged-plugins/${OUTPUT_NAME}"

                echo "✓ Manual signing succeeded"
              fi

              # Cleanup temp directory
              rm -rf "${PLUGIN_DIR}"

              echo "✓ Created ${OUTPUT_NAME}"
            done
          done

          # List created packages
          echo ""
          echo "Created packages:"
          ls -lh packaged-plugins/

      # - name: Upload packages to release
      #   uses: softprops/action-gh-release@v2
      #   with:
      #     files: |
      #       packaged-plugins/*.tgz
      #       packaged-plugins/*.prov
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
